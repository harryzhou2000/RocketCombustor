program main
    implicit none
    integer, parameter :: iofile= 123, curve_max_num_physicalTags=100,&
                          surface_max_num_physicalTags=100,volume_max_num_physicalTags=100,&
                          curve_max_num_boundingPoints=100,surface_max_num_boundingCurves=100,&
                          volume_max_num_boundingSurfaces=100, &
                          numSystemBC=10

    integer, parameter :: max_commenboundary= 100

    integer:: i,j,k,ib
    integer:: numNodes_elementtype(7), systemBC(2,numSystemBC)
    integer:: mesh_dim,filetype, datasize, numPhysicalNames,dimension, physicalTag,numPoints,&
              numCurves, numSurfaces, numVolumes,&
              pointTag,numPhysicalTags,curveTag,surfaceTag,volumeTag,numBoundingPoints,&
              numBoundingCurves,numBoundingSurfaces,&
              numBoundaryConditions,numEntityBlocks,numNodes,minNodeTag,&
              maxNodeTag,total_num_nodes,entityDim,entityTag,parametric,&
              numNodesInBlock,numElements,minElementTag,maxElementTag,&
              elementType,numElementsInBlock,elementTag,&
              numPeriodicBoundary,numPeriodicLinks,entityTagMaster,&
              numAffine,numCorrespondingNodes,peri_nodeTag,peri_nodeTagMaster,numCells,&
              Nsize,numCommenboundary

    integer,allocatable:: Curve_physicalTag(:,:),Curve_boundingPointTag(:,:),&
                          Surface_physicalTag(:,:),Surface_boundingCurveTag(:,:),&
                          Volume_physicalTag(:,:),Volume_boundingSurfaceTag(:,:),&
                          BoundaryConditions(:),numElementsInBoundaryConditions(:),nodeTag(:),&
                          element_physicalTag(:),element_num_nodes(:),element_nodeTag(:,:),&
                          element_entityDim(:),element_entityTag(:),boundaryTag_periodic(:,:),&
                          systemBoundaryConditions(:),IsCommenBoundary(:),IsCommenBoundaryPoint(:,:),&
                          IsCommenBoundaryNode(:,:)

    double precision:: x,y,z,minX,minY,minZ,maxX,maxY,maxZ

    double precision,allocatable:: coord(:,:),transformation_periodic(:,:)
    character(len=127):: name,version,filename,str,str2
    logical:: ifperiodic

    logical,allocatable:: if_right_cell(:), if_right_node(:)
    integer,allocatable:: global_to_local(:),local_to_global(:),right_boundaryTag_periodic(:,:),&
                          commenboundary(:),numElementsInCommenBoundary(:),nodes_commen_boundary(:,:,:),&
                          num_nodes_commen_boundary(:,:)

    logical:: if_right_bound,if_commen_boundary_element
    integer:: num_right_Cells,num_right_Nodes,num_right_PeriodicBoundary, &
              icount,id_cb,id_pb,icommen,inode,icount_cbnode,icount_cbnode_max
    double precision:: x_commen_boundary, x_sum

    integer:: id_max_commenboundary

    logical,external:: contain

    ifperiodic= .false.

    !! System Boundary Conditions Setting
    systemBC=0
    ! systemBC(:,1)=(/10001,100/)
    ! systemBC(:,2)=(/10002,100/)
    ! systemBC(:,3)=(/10003,100/)
    ! systemBC(:,4)=(/10004,100/)

    ! systemBC(:,1)=(/1001,1/)
    ! systemBC(:,2)=(/1002,2/)
    ! systemBC(:,3)=(/1003,3/)
    ! systemBC(:,4)=(/1004,4/)

    systemBC(:,1)=(/1,4/)
    systemBC(:,2)=(/2,3/)
    systemBC(:,3)=(/3,1/)
    systemBC(:,4)=(/4,5/)
    systemBC(:,5)=(/5,2/)
    systemBC(:,6)=(/6,6/)

    numNodes_elementtype=(/2,3,4,4,8,6,5/)



    filename= trim("rocket.msh")
    OPEN(iofile,file=filename,status='old')

    write(*,*) 'reading Gmsh file ...'

    !! $MeshFormat
    read(iofile,*)
    read(iofile,*) version, filetype, datasize
    write(*,*) 'Reading mesh file generated by Gmsh', trim(version)
    if(filetype==1) then
        write(*,*) 'Error: this .msh file is in binary mode, this code can only read ASCII file'
        stop
    endif
    read(iofile,*) 
    !! $EnsMeshFormat

    !! $PhysicalNames
    read(iofile,*)
    read(iofile,*) numPhysicalNames
    do i=1,numPhysicalNames
        read(iofile,*) dimension, physicalTag, name
        write(*,*) 'dimension, physicalTag, physical name:', dimension, physicalTag, trim(name)
	enddo
    read(iofile,*) 
    !! $EndPhysicalNames

    !! $Entities
    read(iofile,*) 
    read(iofile,*) numPoints, numCurves, numSurfaces, numVolumes

    !! dimension of the mesh
    if (numVolumes>0) then
        mesh_dim=3
    else
        mesh_dim=2
    endif

    if(numSurfaces==0) then
        write(*,*) 'we do not deal with 1D mesh';stop
    endif

    !! points
    do i=1,numPoints
        read(iofile,*) pointTag, X, Y, Z, numPhysicalTags
    	if(numPhysicalTags>0) then
            write(*,*) 'Error: the following point has physicalTag:', X,Y,Z
            stop
    	endif
    enddo
    
    !! curves
    allocate(Curve_physicalTag(curve_max_num_physicalTags,numCurves));Curve_physicalTag=0
    allocate(Curve_boundingPointTag(curve_max_num_boundingPoints,numCurves));Curve_boundingPointTag=0
    do i=1,numCurves
        read(iofile,*) curveTag, minX,minY,minZ,maxX,maxY,maxZ,numPhysicalTags,&
        (Curve_physicalTag(j,curveTag),j=1,numPhysicalTags),&
        numBoundingPoints,(Curve_boundingPointTag(j,curveTag),j=1,numBoundingPoints)
    enddo

    !! surfaces, for 2D & 3D meshes
    if(numSurfaces>0) then
    allocate(Surface_physicalTag(surface_max_num_physicalTags,numSurfaces));Surface_physicalTag=0
    allocate(Surface_boundingCurveTag(surface_max_num_boundingCurves,numSurfaces));Surface_boundingCurveTag=0
    do i=1,numSurfaces
        read(iofile,*) surfaceTag,minX,minY,minZ,maxX,maxY,maxZ,numPhysicalTags,&
        (Surface_physicalTag(j,surfaceTag),j=1,numPhysicalTags),&
        numBoundingCurves,(Surface_boundingCurveTag(j,surfaceTag),j=1,numBoundingCurves)
    enddo
    endif

    !! volumes, for 3D meshes
    if(numVolumes>0) then
    allocate(Volume_physicalTag(volume_max_num_physicalTags,numVolumes));Volume_physicalTag=0
    allocate(Volume_boundingSurfaceTag(volume_max_num_boundingSurfaces,numVolumes));Volume_boundingSurfaceTag=0
    do i=1,numVolumes
        read(iofile,*) volumeTag,minX,minY,minZ,maxX,maxY,maxZ,numPhysicalTags,&
        (Volume_physicalTag(j,volumeTag),j=1,numPhysicalTags),&
        numBoundingSurfaces,(Volume_boundingSurfaceTag(j,volumeTag),j=1,numBoundingSurfaces)
    enddo
	endif
    read(iofile,*) 
    !! $EndEntities

    !! collect commen boundaries information
    numCommenboundary=0
    id_max_commenboundary=0
    if(mesh_dim==2) then
        allocate(IsCommenBoundary(numCurves));IsCommenBoundary=0
        do i=1,numSurfaces-1
            do j=1,surface_max_num_boundingCurves
                if(Surface_boundingCurveTag(j,i)/=0) then
                    if( any(abs(Surface_boundingCurveTag(j,i))==abs(Surface_boundingCurveTag(:,i+1:))) ) &
                    IsCommenBoundary(abs(Surface_boundingCurveTag(j,i)))= 1
                endif
            enddo
        enddo
        do i=1,numCurves
            if(IsCommenBoundary(i)>0) then
                numCommenboundary=numCommenboundary+1
                id_max_commenboundary=max(id_max_commenboundary,i)
            endif
        enddo

        do i=1,numCurves
            if(IsCommenBoundary(i)>0 .and. i<id_max_commenboundary) then
                IsCommenBoundary(i)=0
                numCommenboundary=numCommenboundary-1
            endif
        enddo
    elseif(mesh_dim==3) then
        allocate(IsCommenBoundary(numSurfaces));IsCommenBoundary=0
        do i=1,numVolumes-1
            do j=1,volume_max_num_boundingSurfaces
                if(Volume_boundingSurfaceTag(j,i)/=0) then
                    if( any(abs(Volume_boundingSurfaceTag(j,i))==abs(Volume_boundingSurfaceTag(:,i+1:))) ) &
                    IsCommenBoundary(abs(Volume_boundingSurfaceTag(j,i)))= 1
                endif
            enddo
        enddo
        do i=1,numSurfaces
            if(IsCommenBoundary(i)>0) numCommenboundary=numCommenboundary+1
        enddo
    else
        write(*,*) 'error in mesh dimension, mesh_dim=', mesh_dim
        stop
    endif

    write(*,*) 'number of commen boundaries is',numCommenboundary

    allocate(IsCommenBoundaryPoint(2,numPoints));IsCommenBoundaryPoint=0
    do i=1,numCurves
        if(IsCommenBoundary(i)>0) then
            do j=1,curve_max_num_boundingPoints
                pointTag=abs(Curve_boundingPointTag(j,i))
                if(pointTag>0) then
                    if(IsCommenBoundaryPoint(1,pointTag)==0) then
                        IsCommenBoundaryPoint(1,pointTag)= i
                    else
                        if(IsCommenBoundaryPoint(1,pointTag)/=i) IsCommenBoundaryPoint(2,pointTag)=i 
                    endif
                endif
            enddo
        endif
    enddo

    !! collect boundary condition information
    numBoundaryConditions=0
    if(mesh_dim==2) then
        allocate(BoundaryConditions(numCurves)); BoundaryConditions=0
    else
        allocate(BoundaryConditions(numSurfaces)); BoundaryConditions=0
    endif

    if(mesh_dim==2) then
    	do i=1,numCurves
    		if(Curve_physicalTag(1,i)>0) then
                if(numBoundaryConditions>0) then
    				if(.not. contain(Curve_physicalTag(1,i),BoundaryConditions,numBoundaryConditions) ) then
                        numBoundaryConditions= numBoundaryConditions+1
                        BoundaryConditions(numBoundaryConditions)= Curve_physicalTag(1,i)
    				endif
    			else
                    numBoundaryConditions= numBoundaryConditions+1
                    BoundaryConditions(numBoundaryConditions)= Curve_physicalTag(1,i)
    			endif
    		endif
    	enddo
    elseif(mesh_dim==3) then
    	do i=1,numSurfaces
    		if(Surface_physicalTag(1,i)>0) then
                if(numBoundaryConditions>0) then
    				if(.not. contain(Surface_physicalTag(1,i),BoundaryConditions,numBoundaryConditions) ) then
                        numBoundaryConditions= numBoundaryConditions+1
                        BoundaryConditions(numBoundaryConditions)= Surface_physicalTag(1,i)
    				endif
    			else
                    numBoundaryConditions= numBoundaryConditions+1
                    BoundaryConditions(numBoundaryConditions)= Surface_physicalTag(1,i)
    			endif
    		endif
    	enddo
    else
        write(*,*) 'error in mesh dimension, mesh_dim=', mesh_dim
        stop
    endif

    write(*,*) numBoundaryConditions,'boundary conditions:', BoundaryConditions(1:numBoundaryConditions)
    allocate(numElementsInBoundaryConditions(numBoundaryConditions));numElementsInBoundaryConditions=0

    !! $Nodes
    read(iofile,*) 
    read(iofile,*) numEntityBlocks,numNodes,minNodeTag,maxNodeTag

    total_num_nodes=0

    allocate(coord(3,numNodes));coord=0.
    allocate(IsCommenBoundaryNode(2,numNodes));IsCommenBoundaryNode=0
    do i=1,numEntityBlocks
        read(iofile,*) entityDim,entityTag,parametric,numNodesInBlock
        total_num_nodes= total_num_nodes + numNodesInBlock

        allocate(nodeTag(numNodesInBlock));nodeTag=0
        do j=1,numNodesInBlock
            read(iofile,*) nodeTag(j)
            if(entityDim==0) then
                IsCommenBoundaryNode(:,nodeTag(j))=IsCommenBoundaryPoint(:,entityTag)
            elseif(entityDim==mesh_dim-1) then
                if(IsCommenBoundary(entityTag)>0) &
                IsCommenBoundaryNode(1,nodeTag(j))=entityTag
            endif
        enddo

        do j=1,numNodesInBlock
            read(iofile,*) (coord(k,nodeTag(j)),k=1,3)
        enddo

        deallocate(nodeTag)
    enddo
    if(total_num_nodes/=numNodes) then
        write(*,*) 'Error: the sum of numNodesInBlock does not euqal to numNodes';stop
    endif
    read(iofile,*)

    ! do i=1,numNodes
    !     do j=1,2
    !         if(IsCommenBoundaryNode(j,i)<id_max_commenboundary) IsCommenBoundaryNode(j,i)=0
    !     enddo
    ! enddo
    !! $EndNodes

    !! $Elements
    read(iofile,*)
    read(iofile,*) numEntityBlocks,numElements,minElementTag,maxElementTag

    allocate(element_entityDim(numElements));element_entityDim=0
    allocate(element_entityTag(numElements));element_entityTag=0
    allocate(element_nodeTag(maxval(numNodes_elementtype(:)),numElements));element_nodeTag=0
    allocate(element_num_nodes(numElements));element_num_nodes=0
    allocate(element_physicalTag(numElements));element_physicalTag=0

    do i=1,numEntityBlocks
        read(iofile,*) entityDim,entityTag,elementType,numElementsInBlock
    	do j=1,numElementsInBlock
            read(iofile,*) elementTag,(element_nodeTag(k,elementTag),k=1,numNodes_elementtype(elementType))
            element_entityDim(elementTag)= entityDim
            element_entityTag(elementTag)= entityTag
            element_num_nodes(elementTag)= numNodes_elementtype(elementType)

    		if(mesh_dim==3) then  !! 3D mesh
	    		if(entityDim==2) then
                    element_physicalTag(elementTag)= Surface_physicalTag(1,entityTag)
	    		endif
    		else
    			if(entityDim==1) then
                    element_physicalTag(elementTag)= Curve_physicalTag(1,entityTag)
    			endif
    		endif

            do ib=1,numBoundaryConditions
    		if(element_physicalTag(elementTag)==BoundaryConditions(ib)) then
            numElementsInBoundaryConditions(ib)= numElementsInBoundaryConditions(ib)+1
            endif
            enddo
    	enddo
    enddo
    read(iofile,*)
    !! $EndElements

    !! $Periodic
    numPeriodicBoundary= 0
    if(ifperiodic) then
    read(iofile,*)
    read(iofile,*) numPeriodicLinks
    allocate(boundaryTag_periodic(2,numPeriodicLinks));boundaryTag_periodic=0
    allocate(transformation_periodic(mesh_dim,numPeriodicLinks)); transformation_periodic=0.
    do i=1,numPeriodicLinks
        read(iofile,*) entityDim,entityTag,entityTagMaster
    	if(entityDim==mesh_dim-1) then
            
    		do ib=1,numBoundaryConditions
    			if(entityDim==1) then
    				if(Curve_physicalTag(1,entityTag)==BoundaryConditions(ib)) exit
    			else
    				if(Surface_physicalTag(1,entityTag)==BoundaryConditions(ib)) exit
    			endif
    		enddo
            
            if( .not. any(ib==boundaryTag_periodic(:,1:numPeriodicBoundary)) ) then
                numPeriodicBoundary=numPeriodicBoundary+1
                boundaryTag_periodic(1,numPeriodicBoundary)= ib
            else
                cycle
            endif
            

    		do ib=1,numBoundaryConditions
    			if(entityDim==1) then
    				if(Curve_physicalTag(1,entityTagMaster)==BoundaryConditions(ib)) exit
    			else
    				if(Surface_physicalTag(1,entityTagMaster)==BoundaryConditions(ib)) exit
    			endif
    		enddo
            boundaryTag_periodic(2,numPeriodicBoundary)= ib
    	endif
        read(iofile,*) numAffine
    	if(numAffine>0) then
            write(*,*) 'Error: numAffine>0'; stop
    	endif
        read(iofile,*) numCorrespondingNodes
        
        do j=1,numCorrespondingNodes
            read(iofile,*) peri_nodeTag,peri_nodeTagMaster
            if(entityDim==mesh_dim-1) then
            	if(j==1) transformation_periodic(1:mesh_dim,numPeriodicBoundary)= &
                                           coord(1:mesh_dim,peri_nodeTagMaster)-coord(1:mesh_dim,peri_nodeTag)
            endif
        enddo
        
    enddo
    read(iofile,*)
    endif
    !! $EndPeriodic

    close(iofile)
    write(*,*) 'finish reading .msh file'


!!######################################################################
    !! collect information of the mesh
!!######################################################################
    open(iofile,file='grid.in')
    numCells= 0

	do i=1,numElements
		if(element_entityDim(i)==mesh_dim) numCells= numCells + 1
	enddo

    write(iofile,*) numCells,numNodes

    do i=1,numElements
    	if(element_entityDim(i)==mesh_dim) then
           write(iofile,*) element_num_nodes(i), (element_nodeTag(j,i),j=1,element_num_nodes(i))
    	endif
    enddo

    do i=1,numNodes
        write(iofile,*) (coord(j,i),j=1,mesh_dim), (IsCommenBoundaryNode(j,i),j=1,2)
    enddo 

    !! set boundary conditon name 
    allocate(systemBoundaryConditions(numBoundaryConditions));systemBoundaryConditions=0
    do ib=1,numBoundaryConditions
        do j=1,numSystemBC
        if(BoundaryConditions(ib)==systemBC(1,j)) exit
        enddo
        systemBoundaryConditions(ib)=systemBC(2,j)
    enddo

    !! now we collect the boundary points
    write(iofile,*) numBoundaryConditions, maxval(numElementsInBoundaryConditions(:)) 
    do ib=1,numBoundaryConditions
        write(iofile,*) systemBoundaryConditions(ib),numElementsInBoundaryConditions(ib),'*'
    	do i=1,numElements
    		if(element_physicalTag(i)==BoundaryConditions(ib)) then
               write(iofile,*) (element_nodeTag(j,i),j=1,element_num_nodes(i))
        	endif
    	enddo
    enddo

    !! now we write the periodic connection information
    write(iofile,*) 2*numPeriodicBoundary
    do ib=1,numPeriodicBoundary
        write(iofile,*) boundaryTag_periodic(1,ib),boundaryTag_periodic(2,ib),(transformation_periodic(k,ib),k=1,mesh_dim)
        write(iofile,*) boundaryTag_periodic(2,ib),boundaryTag_periodic(1,ib),(-transformation_periodic(k,ib),k=1,mesh_dim)
    enddo

    close(iofile)

    write(*,*) 'finish writing .in file'


!!######################################################################
    !! output VTK file for visualization
!!######################################################################
    OPEN(IOfile,FILE="mesh.vtk") 

    !! header
    str=trim("# vtk DataFile Version 3.0")
    write(IOfile,'(a50)') str
    str=trim("Unstructured Grid Format")
    write(IOfile,'(a50)') str
    str=trim("ASCII")
    write(IOfile,'(a50)') str

    str=trim("DATASET UNSTRUCTURED_GRID")
    write(IOfile,'(a50)') str

    !! coordinates
    write(str,"(I10)") numNodes
    str= trim("POINTS "//trim(str)//" double")
    write(IOfile,'(a50)') str
	do i=1,numNodes
    write(str,'(3es15.8)') coord(1,i), coord(2,i), coord(3,i)
    write(IOfile,'(a)') adjustl(trim(str))
	enddo

    !! Cell nodes
    Nsize=numCells
    do i=1,numElements
    	if(element_entityDim(i)==mesh_dim) then
           Nsize= Nsize + element_num_nodes(i)
    	endif
    enddo

    write(str,"(I10)") numCells
    write(str2,"(I10)") Nsize
    str= trim("CELLS "//trim(str)//trim(str2))
    write(IOfile,'(a50)') str
    do i=1,numElements
    if(element_entityDim(i)==mesh_dim) then
    	if (element_num_nodes(i)==3) then
            write(str,'(4I10)') element_num_nodes(i), (element_nodeTag(j,i)-1,j=1,element_num_nodes(i))
            write(IOfile,'(a)') adjustl(trim(str))
    	else
            write(str,'(5I10)') element_num_nodes(i), (element_nodeTag(j,i)-1,j=1,element_num_nodes(i))
            write(IOfile,'(a)') adjustl(trim(str))
    	endif
    endif

	enddo

    !! Cell types: tri:5, quad:9
    write(str,"(I10)") numCells
    str= trim("CELL_TYPES "//trim(str))
    write(IOfile,'(a50)') str
    ! do i=1,NE
    ! if (kface(i)==3) then
    !   write(str3,'(I1)') 5
    !   write(IOfile,'(a)') adjustl(trim(str3))
    ! else
    !   write(str3,'(I1)') 9
    !   write(IOfile,'(a)') adjustl(trim(str3))
    ! endif
    ! enddo

	do i=1,numElements
	if(element_entityDim(i)==mesh_dim) then
		if (element_num_nodes(i)==3) then
            write(str,'(I1)') 5
            write(IOfile,'(a)') adjustl(trim(str))
		else
            write(str,'(I1)') 9
            write(IOfile,'(a)') adjustl(trim(str))
		endif
	endif
	enddo

    !! cell-center data
    write(str,'(I10)') numNodes
    str= trim("POINT_DATA "//trim(str))
    write(IOfile,'(a50)') str

    str= trim("SCALARS commonboundary double")
    write(IOfile,'(a50)') str
    str=trim("LOOKUP_TABLE default")
    write(IOfile,'(a50)') str
    do i=1,numNodes
    write(str,'(I10)') IsCommenBoundaryNode(1,i)
    write(IOfile,'(a)') adjustl(trim(str))
    ! if(IsCommenBoundaryNode(1,i)>0)   write(*,*) IsCommenBoundaryNode(1,i)
    enddo

    close(iofile)

    write(*,*) 'finish writing .vtk file'

!!######################################################################
!!     only keep the right part
!!######################################################################

    allocate(if_right_cell(numElements));if_right_cell=.false.
    allocate(if_right_node(numNodes));if_right_node=.false.

    do i=1,numNodes
        if(IsCommenBoundaryNode(1,i)>0) then
            x_commen_boundary= coord(1,i) 
            exit
        endif
    enddo 

    num_right_Cells= 0
    do i=1,numElements
        if(element_entityDim(i)==mesh_dim) then
            x_sum=0.
            do j=1,element_num_nodes(i)
                x_sum = x_sum + coord(1,element_nodeTag(j,i))
            enddo
            x_sum=x_sum/element_num_nodes(i)
            if(x_sum>x_commen_boundary) then
                if_right_cell(i)= .true.
                num_right_Cells= num_right_Cells + 1
                do j=1,element_num_nodes(i)
                    if_right_node(element_nodeTag(j,i))= .true.
                enddo
            endif
        endif
    enddo

    
    num_right_Nodes=0
    do i=1,numNodes
        if(if_right_node(i)) num_right_Nodes=num_right_Nodes+1
    enddo

    allocate(global_to_local(numNodes));global_to_local=0    
    allocate(local_to_global(num_right_Nodes));local_to_global=0
    num_right_Nodes=0
    do i=1,numNodes
        if(if_right_node(i)) then
            num_right_Nodes=num_right_Nodes+1
            global_to_local(i)= num_right_Nodes
            local_to_global(num_right_Nodes)= i
        endif
    enddo

    open(iofile,file='grid_right.in')

    write(iofile,*) num_right_Cells,num_right_Nodes

    do i=1,numElements
        if(if_right_cell(i)) then
           write(iofile,*) element_num_nodes(i), (global_to_local(element_nodeTag(j,i)),j=1,element_num_nodes(i))
        endif
    enddo

    do i=1,num_right_Nodes
        write(iofile,*) (coord(j,local_to_global(i)),j=1,mesh_dim), (IsCommenBoundaryNode(j,local_to_global(i)),j=1,2)
    enddo 

    !! set the boundary points for the reduced domain
    do ib=1,numBoundaryConditions
        icount=0
        do i=1,numElements
            if( element_physicalTag(i)==BoundaryConditions(ib)) then
                if_right_bound=.true.
                do j=1,element_num_nodes(i)
                    if(.not. if_right_node(element_nodeTag(j,i))) if_right_bound= .false.
                enddo
                if(if_right_bound) icount=icount+1
            endif
        enddo
        numElementsInBoundaryConditions(ib)=icount
    enddo

    ! write(*,*) numElementsInBoundaryConditions,systemBoundaryConditions

    !! set the boundary conditions index for the broken or missing periodic boundaries
    allocate(right_boundaryTag_periodic(2,numPeriodicBoundary));right_boundaryTag_periodic=0
    num_right_PeriodicBoundary=0
    do ib=1,numPeriodicBoundary
        if (numElementsInBoundaryConditions(boundaryTag_periodic(1,ib))==0 .or. &
            numElementsInBoundaryConditions(boundaryTag_periodic(2,ib))==0) then
            systemBoundaryConditions(boundaryTag_periodic(1,ib))=systemBoundaryConditions(boundaryTag_periodic(1,ib)) + 100
            systemBoundaryConditions(boundaryTag_periodic(2,ib))=systemBoundaryConditions(boundaryTag_periodic(2,ib)) + 100
            cycle
        endif
        
        num_right_PeriodicBoundary=num_right_PeriodicBoundary+1

        id_pb=0
        do j=1,boundaryTag_periodic(1,ib)
            if(numElementsInBoundaryConditions(j)>0) id_pb=id_pb+1
        enddo
        right_boundaryTag_periodic(1,ib)=id_pb

        id_pb=0
        do j=1,boundaryTag_periodic(2,ib)
            if(numElementsInBoundaryConditions(j)>0) id_pb=id_pb+1
        enddo
        right_boundaryTag_periodic(2,ib)=id_pb
    enddo

    !! count the number of commen boundary
    allocate(commenboundary(numCommenboundary));commenboundary=0
    icommen=0
    do i=1,numNodes
        if(IsCommenBoundaryNode(1,i)>0) then
            if(.not. any(IsCommenBoundaryNode(1,i)==commenboundary(:))) then
                icommen=icommen+1
                commenboundary(icommen)=IsCommenBoundaryNode(1,i)
                if(icommen>numCommenboundary) then
                    write(*,*) 'error in finding commonboundary,numCommenboundary=',numCommenboundary,'while icommen=',icommen
                    stop
                endif
            endif
        endif
    enddo

    write(*,*) 'commen boundaries:',commenboundary

    allocate(numElementsInCommenBoundary(numCommenboundary));numElementsInCommenBoundary=0
    icount_cbnode_max=0
    do i=1,numElements
        if(if_right_cell(i)) then
            if_commen_boundary_element= .false.
            id_cb=0
            do j=1,element_num_nodes(i)
                inode=element_nodeTag(j,i)
                if(IsCommenBoundaryNode(1,inode) >0 .and. IsCommenBoundaryNode(2,inode)==0) &
                    id_cb= IsCommenBoundaryNode(1,inode)
            enddo

            if(id_cb==0) cycle
            icount_cbnode=0
            do j=1,element_num_nodes(i)
                inode=element_nodeTag(j,i)
                if(IsCommenBoundaryNode(1,inode) == id_cb .or. IsCommenBoundaryNode(2,inode) == id_cb) &
                    icount_cbnode=icount_cbnode+1
            enddo

            if(icount_cbnode>mesh_dim-1) if_commen_boundary_element=.true.
            icount_cbnode_max=max(icount_cbnode_max,icount_cbnode)

            ! write(*,*)  if_commen_boundary_element,id_cb

            if(if_commen_boundary_element) then
                do ib=1,numCommenboundary
                    if(id_cb==commenboundary(ib)) exit
                enddo
                numElementsInCommenBoundary(ib)= numElementsInCommenBoundary(ib)+1
            endif
        endif
    enddo

    allocate(num_nodes_commen_boundary(maxval(numElementsInCommenBoundary),numCommenboundary));num_nodes_commen_boundary=0
    allocate(nodes_commen_boundary(icount_cbnode_max,maxval(numElementsInCommenBoundary),numCommenboundary));nodes_commen_boundary=0
    numElementsInCommenBoundary=0
    do i=1,numElements
        if(if_right_cell(i)) then
            if_commen_boundary_element= .false.
            id_cb=0
            do j=1,element_num_nodes(i)
                inode=element_nodeTag(j,i)
                if(IsCommenBoundaryNode(1,inode) >0 .and. IsCommenBoundaryNode(2,inode)==0) &
                    id_cb= IsCommenBoundaryNode(1,inode)
            enddo

            if(id_cb==0) cycle
            icount_cbnode=0
            do j=1,element_num_nodes(i)
                inode=element_nodeTag(j,i)
                if(IsCommenBoundaryNode(1,inode) == id_cb .or. IsCommenBoundaryNode(2,inode) == id_cb) &
                    icount_cbnode=icount_cbnode+1
            enddo

            if(icount_cbnode>mesh_dim-1) if_commen_boundary_element=.true.

            if(if_commen_boundary_element) then
                do ib=1,numCommenboundary
                    if(id_cb==commenboundary(ib)) exit
                enddo
                numElementsInCommenBoundary(ib)= numElementsInCommenBoundary(ib)+1

                !! collect the commen boundary elements
                icount_cbnode=0
                do j=1,element_num_nodes(i)
                    inode=element_nodeTag(j,i)
                    if(IsCommenBoundaryNode(1,inode) == id_cb .or. IsCommenBoundaryNode(2,inode) == id_cb) then
                        icount_cbnode=icount_cbnode+1
                        nodes_commen_boundary(icount_cbnode,numElementsInCommenBoundary(ib),ib)=inode
                    endif
                enddo
                num_nodes_commen_boundary(numElementsInCommenBoundary(ib),ib)=icount_cbnode
            endif
        endif
    enddo

    write(*,*) 'commen boundary elements:',numElementsInCommenBoundary

    
    !! compute the number of existing boundary conditions + common boundary
    icount=numCommenboundary
    do i=1,numBoundaryConditions
        if(numElementsInBoundaryConditions(i)>0) icount=icount+1
    enddo

    !! now we collect the boundary points
    write(iofile,*) icount, max(maxval(numElementsInBoundaryConditions(:)), maxval(numElementsInCommenBoundary(:)))
    do ib=1,numBoundaryConditions
        if(numElementsInBoundaryConditions(ib)>0) then
            ! write(*,*) ib,systemBoundaryConditions(ib),numElementsInBoundaryConditions(ib)
            write(iofile,*) systemBoundaryConditions(ib),numElementsInBoundaryConditions(ib)
            do i=1,numElements
                if( element_physicalTag(i)==BoundaryConditions(ib)) then
                    if_right_bound=.true.
                    do j=1,element_num_nodes(i)
                        if(.not. if_right_node(element_nodeTag(j,i))) if_right_bound= .false.
                    enddo
                    if(if_right_bound) write(iofile,*) (global_to_local(element_nodeTag(j,i)),j=1,element_num_nodes(i))
                endif
            enddo
        endif
    enddo

    !! now we collect the common boundary points
    do ib=1,numCommenboundary
        write(iofile,*) commenboundary(ib)+1000,numElementsInCommenBoundary(ib)
        do i=1,numElementsInCommenBoundary(ib)
            write(iofile,*) (global_to_local(nodes_commen_boundary(j,i,ib)),j=1,num_nodes_commen_boundary(i,ib))
        enddo
    enddo

    !! now we write the periodic connection information
    write(iofile,*) 2*num_right_PeriodicBoundary
    do ib=1,numPeriodicBoundary
        if (numElementsInBoundaryConditions(boundaryTag_periodic(1,ib))==0 .or. &
            numElementsInBoundaryConditions(boundaryTag_periodic(2,ib))==0) cycle
        write(iofile,*) right_boundaryTag_periodic(1,ib),right_boundaryTag_periodic(2,ib),&
                        ( transformation_periodic(k,ib),k=1,mesh_dim)
        write(iofile,*) right_boundaryTag_periodic(2,ib),right_boundaryTag_periodic(1,ib),&
                        (-transformation_periodic(k,ib),k=1,mesh_dim)
    enddo

    close(iofile)

    write(*,*) 'finish writing grid_right.in file'


!!######################################################################
!!  output VTK file for visualization for the right domain
!!######################################################################
    OPEN(IOfile,FILE="mesh_right.vtk") 

    !! header
    str=trim("# vtk DataFile Version 3.0")
    write(IOfile,'(a50)') str
    str=trim("Unstructured Grid Format")
    write(IOfile,'(a50)') str
    str=trim("ASCII")
    write(IOfile,'(a50)') str

    str=trim("DATASET UNSTRUCTURED_GRID")
    write(IOfile,'(a50)') str

    !! coordinates
    write(str,"(I10)") num_right_Nodes
    str= trim("POINTS "//trim(str)//" double")
    write(IOfile,'(a50)') str
    do i=1,num_right_Nodes
    write(str,'(3es15.8)') coord(1,local_to_global(i)), coord(2,local_to_global(i)), coord(3,local_to_global(i))
    write(IOfile,'(a)') adjustl(trim(str))
    enddo

    !! Cell nodes
    Nsize=num_right_Cells
    do i=1,numElements
        if(if_right_cell(i)) then
           Nsize= Nsize + element_num_nodes(i)
        endif
    enddo

    write(str,"(I10)") num_right_Cells
    write(str2,"(I10)") Nsize
    str= trim("CELLS "//trim(str)//trim(str2))
    write(IOfile,'(a50)') str
    do i=1,numElements
    if(if_right_cell(i)) then
        if (element_num_nodes(i)==3) then
            write(str,'(4I10)') element_num_nodes(i), (global_to_local(element_nodeTag(j,i))-1,j=1,element_num_nodes(i))
            write(IOfile,'(a)') adjustl(trim(str))
        else
            write(str,'(5I10)') element_num_nodes(i), (global_to_local(element_nodeTag(j,i))-1,j=1,element_num_nodes(i))
            write(IOfile,'(a)') adjustl(trim(str))
        endif
    endif
    enddo

    !! Cell types: tri:5, quad:9
    write(str,"(I10)") num_right_Cells
    str= trim("CELL_TYPES "//trim(str))
    write(IOfile,'(a50)') str

    do i=1,numElements
    if(if_right_cell(i)) then
        if (element_num_nodes(i)==3) then
            write(str,'(I1)') 5
            write(IOfile,'(a)') adjustl(trim(str))
        else
            write(str,'(I1)') 9
            write(IOfile,'(a)') adjustl(trim(str))
        endif
    endif
    enddo

    !! cell-center data
    write(str,'(I10)') num_right_Nodes
    str= trim("POINT_DATA "//trim(str))
    write(IOfile,'(a50)') str

    str= trim("SCALARS commonboundary double")
    write(IOfile,'(a50)') str
    str=trim("LOOKUP_TABLE default")
    write(IOfile,'(a50)') str
    do i=1,num_right_Nodes
    write(str,'(I10)') IsCommenBoundaryNode(1,local_to_global(i))
    write(IOfile,'(a)') adjustl(trim(str))
    ! if(IsCommenBoundaryNode(1,i)>0)   write(*,*) IsCommenBoundaryNode(1,i)
    enddo

    close(iofile)

    write(*,*) 'finish writing mesh_right.vtk file'


end program


logical function contain(in,iarr,n)
    implicit none
    integer :: in,n,iarr(n),i
    do i=1,n
    if( in==iarr(i) )then
      contain= .true.
      return
    endif
    enddo
    contain=.false.
end function